bnfc -m -haskell Rose.cf
make

test=("{Int} v = 2 + 2 * 31"
      "{Int} v = let {Int} a = 10 in 10"
      "{Int} v = let {Int} a = 10; {Int} b = 20 in 10"
      "{Int -> Int} l = \Int x -> x + 10"
      "{Int} v = if 10 then 10 else 10"
      "{Int} v = if a < 10 then 5 else 2" 
      "{Int} v = if 5 < 10 then a else b"
      "{Int} v = let {Int}  a = if 5 < 10 then a else 10 in a"
      "{Int} v = mojafunkcja a b c d e"
      "{Int} v = case x of [] -> 0"
      "{Int} v = case x of (x:xf) -> 1"
      "{Int} v = case x of (x:xf) -> 1 | [] -> 2"
      "{Int} v = case x of Value (x:xf) -> 1"
      "{Int} v = case x of 1 -> 1 | 2 -> 2"
      "{Int} v = case x of Value 2 -> 2"
      "{Int} v = case x of ((Value x):xf) -> 1"
      "{Int} v = let {Int -> Int} a = 10 in 10"
      "{Int} v = let {Int -> Int} a = if 10 then 10 else 20 in 10"
      "{Int} v = let {Int} a = \Int x -> x + 10 in 10"
      "{Int} fun a = a"
      "{Int} fun a b c d = a b c"
      "data Integer = Int"
      "data Maybe = Just Int String"
      "data Bool = True | False"
      "data Maybe = Just Int | Nothing"
      "data Maybe = Just Int | Only Int"
      "{Int} v = case x of (x:(y:ys)) -> y"
      "{Int} v = case x of _ -> x"
      "{Int} v = case x of (x:_) -> x"
      "{Int} v = case x of (_:xs) -> xs"
      "{Int} v = case x of True -> xs | False -> x"
      "{Int} v = 1"
      "{Int} v = case x of (x:[]) -> x"
      "{Int} v = [1,2,3,4]"
      "{Int} v = case x of ([1,2,3]:xs) -> xs"
      "{<a> -> <a>} fun x y = x"
      "{<a> -> [<a>]} fun x y = x"
      "{Int} v = 1 && 2"
      "{Int} v = 1 || 2"
      "{Int} v = if (True) then 5 else 2"
      "{Int} v = (Value (X 5 5) (Y 1 2))"
      "{Int} v = fun a b c d"
      "{Int} b = 4; {Int} c = 10; {Int} (d:e) = [1,2]"
      "{Int} b = case x of ((x:xf):(y:ys)) -> x"
      "{Int} b = case x of (((Value x):xf):(y:ys)) -> x"
      "{Int} b = [1,2]"
      "{Int} (a:(x:y)) = [1,2]"
      "{Int} a = let {Int} (x:y) = [1,2] in x"
     )

for t in "${test[@]}"; do
  echo "$t" | ./TestRose
done
